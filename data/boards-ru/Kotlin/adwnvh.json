{"subreddit":{"display_name":"Kotlin"},"subreddit_loc":"Котлин","selftext":"Я просто хотел поделиться недавним выпуском проекта, над которым я работал. [Kroto +]  (https://github.com/marcoferrer/kroto-plus)  теперь поддерживает создание клиентских и служебных заглушек gRPC на основе сопрограмм. Вы можете клонировать и запустить следующий предварительно настроенный [шаблон проекта]  (https://github.com/marcoferrer/kotlin-coroutines-gRPC-template) . Существующие пользователи Kroto + могут добавить `grpc_coroutines {}` в свою конфигурацию сборки.\n\n* ** Обратное давление ** поддерживается через [Ручное управление потоком] <span translate = \"no\"> (https://github.com/grpc/grpc-java/tree/master/examples/src/main/java/ IO / КПГР / примеры / manualflowcontrol) </ SPAN>\n   * Связанное чтение: [Понимание реактивного управления потоком gRPC]  (https://github.com/salesforce/reactive-grpc#back-pressure) \n* ** Совместное аннулирование ** распространяется через границы сети. Это означает, что отмененный клиент `coroutineContext`, подключенный к заглушке, отменит соответствующее задание rpc внутри службы.\n* Полный двунаправленный поток с использованием сопрограмм каналов\n* Клиентские окурки\n   * Реализовать интерфейс `CoroutineScope`\n   * Предназначен для работы с ** структурированным параллелизмом **\n   * Отмена теперь может распространяться на использование определенного экземпляра заглушки.\n   * Методы Rpc ​​перегружены встроенными компоновщиками для типов запросов\n\n\n\n    // КЛИЕНТ\n    val stub = GreeterCoroutineGrpc.newStub (канал)\n        .withCoroutineContext () // или .withCoroutineContext (coroutineContext)\n    \n    val response = stub.sayHello {name = \"Джон\"}\n    \n    // СЛУЖБА\n    переопределить приостановить веселье sayHello (запрос: HelloRequest): HelloReply = coroutineScope {\n        if (isValid (request.name))\n            HelloReply {message = \"Привет, $ {request.name}!\" } еще\n            бросить Status.INVALID_ARGUMENT.asRuntimeException ()\n    }\n\nПримеры других вариантов RPC можно найти [здесь]  (https://github.com/marcoferrer/kroto-plus#examples) .\n\nKroto + также поддерживает генерацию лямбда-компоновщиков и расширений для протологических сообщений.\n\n        val attack = Attack {\n            name = \"ORA ORA ORA\"\n            урон = 100\n            range = StandProto.Attack.Range.CLOSE\n        }\n        \n        // Копирование расширений также генерируется\n        val newAttack = attack.copy {урон = 200}\n        \n        // а также расширения оператора плюс\n        val mergedAttack = attack + Attack {name = \"Солнечный свет с желтой перегрузкой\"}\n\nЛюбые отзывы приветствуются, а также предложения для новых функций и улучшений.\n\nТакже в работе представлен прототип для генерации многоплатформенных классов данных из прототипов с использованием [Kotlinx Serialization]  (https://github.com/Kotlin/kotlinx.serialization) . Не стесняйтесь участвовать в [обсуждении дизайна]  (https://github.com/marcoferrer/kroto-plus/issues/21) .\n\n","title":"gRPC + Kotlin + Coroutines: выпущен Kroto + 0.2.2-RC1 с асинхронным генератором кода клиента / услуги с поддержкой противодавления.","subreddit_name_prefixed":"r/Kotlin","ups":14,"created":1546997644,"link_flair_background_color":"","id":"adwnvh","author":{"name":"marrferr"},"permalink":"/r/Kotlin/comments/adwnvh/grpc_kotlin_coroutines_kroto_022rc1_is_released/","url":"https://www.reddit.com/r/Kotlin/comments/adwnvh/grpc_kotlin_coroutines_kroto_022rc1_is_released/","created_utc":1546968844}