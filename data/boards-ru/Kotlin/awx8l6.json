{"subreddit":{"display_name":"Kotlin"},"subreddit_loc":"Котлин","selftext":"В настоящее время я использую Kotlin в качестве альтернативы Java, и я хочу избежать использования потребителей / фьючерсов, так как я могу использовать сопрограммы. Я читал, что не должен использовать GlobalScope для входа в контекст сопрограммы, потому что эти сопрограммы не уничтожаются, когда задача завершена. Если я сделаю:\n\n    runBlocking {\n        withContext (asyncDispatcher) {println (Thread.currentThread.name)}\n    }\n\nтогда основной поток заходит в тупик. Использование диспетчера синхронизации вполне нормально. Нужно ли создавать свой собственный класс области видимости сопрограмм, так как runBlocking не корректен?\n\nОкончательное редактирование: я понял это; сделал свой собственный CoroutineScope и сделал на нем ссылку на латинит верхнего уровня, так что теперь я могу просто создать его при запуске и отменить его при завершении работы. В основном синтаксис:\n\n    fun loadAsync (): отложено <Boolean> = myScope.async {/ * получить элемент * /}\n\nЗатем в другом месте я делаю `myScope.launch {/ * жду здесь * /}` и жду его внутри. Это ** НЕ ** останавливает основной поток, несмотря на то, что запуск по умолчанию является основным потоком.","title":"Помогите понять границы сопрограмм (не Android)","subreddit_name_prefixed":"r/Kotlin","ups":14,"created":1551668726,"link_flair_background_color":"","id":"awx8l6","author":{"name":"atomicfable"},"permalink":"/r/Kotlin/comments/awx8l6/help_understanding_coroutine_scopes_not_android/","url":"https://www.reddit.com/r/Kotlin/comments/awx8l6/help_understanding_coroutine_scopes_not_android/","created_utc":1551639926}