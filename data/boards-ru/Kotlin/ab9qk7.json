{"subreddit":{"display_name":"Kotlin"},"subreddit_loc":"Котлин","selftext":"Я тестирую JOOQ. Один класс имеет следующие вызовы:\n\n    аннулировать транзакцию (TransactionalRunnable транзакция);\n    аннулировать транзакцию (ContextTransactionalRunnable транзакция);\n\nГде ContextTransactionalRunnable - SAM с методом void run (), а TransactionalRunnable - SAM с void run (конфигурация конфигурации).\n\nЯ пытаюсь назвать это в моей программе; однако компилятор Kotlin не может определить, какой именно вызов транзакции (я) хочу, если я не укажу фиктивный лямбда-аргумент:\n\n    dsl.transaction {_ ->\n        // материал\n    }\n\nЭто разрешает вызов `void транзакция (TransactionalRunnable транзакция)`, поскольку `_` выводится как тип` Configuration`. Однако при проверке кода intelliJ правильно упоминается, что это избыточный аргумент, и когда он удаляется, я получаю следующую ошибку:\n\n    Перегрузка разрешает неоднозначность. Все эти функции совпадают.\n      публичная финальная забавная транзакция (транзакция: (() → Unit)!): единица, определенная в org.jooq.DSLContext\n      публичная финальная забавная транзакция (транзакция: ((конфигурация: конфигурация!) → блок)!): блок определен в org.jooq.DSLContext\n\nЯвная установка аргумента в `_: Unit` также не разрешает это.","title":"Неоднозначность разрешения перегрузки с лямбдами","subreddit_name_prefixed":"r/Kotlin","ups":8,"created":1546309566,"link_flair_background_color":"","id":"ab9qk7","author":{"name":"couscous_"},"permalink":"/r/Kotlin/comments/ab9qk7/overload_resolution_ambiguity_with_lambdas/","url":"https://www.reddit.com/r/Kotlin/comments/ab9qk7/overload_resolution_ambiguity_with_lambdas/","created_utc":1546280766}