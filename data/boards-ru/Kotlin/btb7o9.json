{"subreddit":{"display_name":"Kotlin"},"subreddit_loc":"Котлин","selftext":"У меня есть класс данных, который создает список экземпляров карт и возвращает их при необходимости. Конструктор является закрытым, поэтому любые две карты одного и того же значения обязательно являются одним и тем же объектом.\n`` `Котлин\nЗакрытый конструктор класса данных Card (значение типа: Int) {\n\n    сопутствующий объект {\n\n        private val CARDS = Список (54) {Карта (это)}\n\n        fun get (значение: Int) = CARDS [значение]\n\n        оператор fun invoke (значение: Int) = CARDS [значение]\n\n    }\n}\n`` `\nКакой способ получения экземпляров карты вы считаете лучшим: `get` (или любой другой именованный метод) или` invoke`? У них другой синтаксис:\n- Вызвать: `val card = Card (13)`.\n- Заводской метод: `val card = Card.get (13)`.\n\nСчитается ли это плохой практикой, поскольку он выглядит так же, как конструктор, но не является таковым? Я не вижу, что еще может вызвать на объект-компаньон, хотя для.","title":"Вызвать сопутствующий объект против именованного фабричного метода","subreddit_name_prefixed":"r/Kotlin","ups":4,"created":1558923623,"link_flair_background_color":"","id":"btb7o9","author":{"name":"rvkUJApH34uqa5Wh8M4K"},"permalink":"/r/Kotlin/comments/btb7o9/invoke_on_companion_object_vs_named_factory_method/","url":"https://www.reddit.com/r/Kotlin/comments/btb7o9/invoke_on_companion_object_vs_named_factory_method/","created_utc":1558894823}