{"subreddit":{"display_name":"Kotlin"},"subreddit_loc":"Котлин","selftext":"Привет р / котлин,\n\n    val list: List <Int> = listOf () // работает\n    \n    val list: List <Int> = listOf (). Также {println (it)} // не компилируется\n\nПо моему мнению, компилятор должен иметь возможность выводить обобщенные значения `listOf ()`, поскольку он должен иметь возможность выводить `first ()`, а затем `listOf ()`.\n\nЕсть идеи, почему компилятор Kotlin не может? Было бы сложно и замедлить время компиляции?\n\n\n\nЭто пригодится в следующем примере:\n\n    класс Person (val firstName: String, val lastName: String)\n    \n    val people = listOf <Person> ()\n    \n    // компилирует:\n    people.sortedWith (compareByDescending <Person> {it.lastName} .thenBy {it.firstName})\n    \n    // лучше, но не компилируется:\n    people.sortedWith (compareByDescending {it.lastName} .thenBy {it.firstName})","title":"Обратный вывод типа в цепочечных вызовах","subreddit_name_prefixed":"r/Kotlin","ups":11,"created":1571418891,"link_flair_background_color":"","id":"djkwdd","author":{"name":"Astronaut4449"},"permalink":"/r/Kotlin/comments/djkwdd/reversed_type_inference_in_chained_calls/","url":"https://www.reddit.com/r/Kotlin/comments/djkwdd/reversed_type_inference_in_chained_calls/","created_utc":1571390091}