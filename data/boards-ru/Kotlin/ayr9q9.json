{"subreddit":{"display_name":"Kotlin"},"subreddit_loc":"Котлин","selftext":"Привет всем.\n\n\nЯ работаю над проектом в Ktor, используя Exposed ORM для связи с базой данных MySQL. В настоящее время я пытаюсь написать несколько тестов, как задокументировано [здесь]  (https://ktor.io/servers/testing.html#building-postput-idity) .\n\n\nСейчас, когда я пишу свой первый полезный тест, я сталкиваюсь с множеством трудностей. Мне было интересно, может ли кто-нибудь здесь помочь мне или вывести меня на правильный путь. Здесь есть много проблем, и все они кажутся взаимосвязанными на данный момент. Это длинный пост. Я также опубликую это в r / learnprogramming.\n\n\nПроблемы и их контекст:\n\n* У меня есть функция `fun Route.auth (dataQuerier: IDataQuerier, [Еще несколько дополнительных экземпляров классов в качестве параметров, но я оставляю их для удобства чтения))`\nкоторый имеет PUT-конечную точку. Эта конечная точка является конечной точкой, которую я хочу проверить. Эта конечная точка полагается на `dataQuerier`, который он получает через параметры` Route.auth`\n* `dataQuerier` является экземпляром` class DataQuerier: IDataQuerier`, который реализует `интерфейс IDataQuerier`. Этот класс и интерфейс несут исключительную ответственность за обработку всех запросов к базе данных. Так что это основные ворота для всех транзакций базы данных, которые я выполняю с помощью Exposed ORM. Из-за написания теста я хочу, чтобы этот экземпляр был Mocked. Этот экземпляр должен не выполнять транзакции с базой данных, а просто возвращать фиктивные данные и тому подобное.\n* Одной из функций, определенных в `IDataQuerier`, является` fun findUser (email: String): User? `. Эта функция возвращает экземпляр User, который формирует часть проблемы с Exposed ORM. Для справки я использовал [эту статью]  (https://www.baeldung.com/kotlin-exposed-persistence)  для объявления этого объекта. Итак, вот так выглядит класс User и его эквивалент ORM. Я использую метод DAO, что означает, что у меня есть `Object Users` и` class User`\n   * `// Создать модель, которая представляет таблицу в базе данных для Entity: User`\n`Object Users: IntIdTable (\" User \") {`\n `val email: Column <String> = Users.varchar (\" Электронная почта \", 100) .uniqueIndex ()`\n `val пароль: столбец <String> = Users.varchar (\" пароль \", 1000)`\n `val refreshToken: Column <String?> = Users.varchar (\" RefreshToken \", 50) .nullable ()`\n``}\n   * `// Включить объект доступа к данным (DAO) для более удобных транзакций данных`\n`Class User (id: EntityID <Int>): Entity <Int> (id) {`\n `сопутствующий объект: EntityClass <Int, User> (Users)`\n`var email by Users.email`\n `var password by Users.password`\n `var refreshToken by Users.refreshToken`\n``}\nЛогично, что я хочу, чтобы экземпляр класса User был Mocked, а не вытащен из базы данных. Это не работает, так как мне не удается добавить макетированный экземпляр DataQuerier в Route.auth и запретить коду использовать немодированную версию этого экземпляра. Я следую [этому примеру]  (https://github.com/ktorio/ktor-samples/blob/master/app/kweet/test/KweetApplicationTest.kt)  из Ktor. официальная документация, где (по-видимому) код может внедрить макет непосредственно в [их функцию Route.Index] <span translate = \"no\"> (https://github.com/ktorio/ktor-samples/blob/master /app/kweet/src/Index.kt) </ SPAN>. Кажется, там работает, но у меня не работает ...\nИх функция Route.Index по сути является моей функцией Route.auth. Их функция принимает экземпляр `interface DAOFacade`, тогда как моя функция принимает экземпляр` interface IDataQuerier`.\n* Исходя из этой информации, примера, который я связал, и моих знаний, это мой метод испытаний, который мне удалось записать. Я не уверен, что все настроено правильно, но поэтому я все равно обращаюсь к вам, ребята ...\n\n\n\n`val dqMock = mockk <IDataQuerier> ()`\n\n@Тестовое задание\n\n* `fun testSomething () {`\n`val dataToBeSentToEndpoint = LoginDC (email =\" paolo@company.com \", пароль =\" пароль \")`\n`Every {dqMock.findUser (\" paolo@company.com \")} возвращает = Пользователь (EntityID (8, таблица = Пользователи))`\n`С (двигатель) {`\n`handleRequest (HttpMethod.Put,\" / auth / login \") {`\n`addHeader (HttpHeaders.ContentType, ContentType.Application.Json.toString ())`\n`SetBody (jacksonObjectMapper (). WriteValueAsString (dataToBeSentToEndpoint))`\n`} .apply {`\n`assertEquals (HttpStatusCode.OK, response.status ())`\n``}\n``}\n``}\n\n\nПри отладке я попадаю в код, который хочу протестировать, размещая там точки останова, но он не может получить смоделированную версию dataQuerier: он по-прежнему получает данные из базы данных. В идеале я бы просто вызвал Route.auth и пропустил объект, но Ktor этого не позволяет ...\n\n\nИтак, кто-нибудь может мне помочь?\n\n  \n\n\n","title":"[Требуется помощь] Тестирование приложения Ktor, с Exposed ORM и MockK","subreddit_name_prefixed":"r/Kotlin","ups":4,"created":1552086430,"link_flair_background_color":"","id":"ayr9q9","author":{"name":"IP14Y3RI"},"permalink":"/r/Kotlin/comments/ayr9q9/help_needed_testing_ktor_application_with_exposed/","url":"https://www.reddit.com/r/Kotlin/comments/ayr9q9/help_needed_testing_ktor_application_with_exposed/","created_utc":1552057630}