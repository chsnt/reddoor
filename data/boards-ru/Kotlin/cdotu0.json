{"subreddit":{"display_name":"Kotlin"},"subreddit_loc":"Kotlin","selftext":"","title":"intellectuals ? will : understand","subreddit_name_prefixed":"r/Kotlin","ups":123,"created":1563260293,"link_flair_background_color":"","id":"cdotu0","author":{"name":"Tok-A-Mak"},"permalink":"/r/Kotlin/comments/cdotu0/intellectuals_will_understand/","url":"https://i.redd.it/tybd6qr5sja31.png","created_utc":1563231493,"replies":[{"ups":28,"link_id":"t3_cdotu0","replies":[{"ups":3,"link_id":"t3_cdotu0","id":"etxsy6h","author":"notquiteaplant","parent_id":"t1_etwirij","subreddit_id":"t5_2so2r","body":"1. Both sides are evaluated. Because the operator is `<T> T.div(rhs: T)` rather than `<T> (() -> T).div(rhs: () -> T)`, both arguments are evaluated eagerly.\n2. Function return types are covariant, so this compiles but the type of ``bool `?` \"' / { Unit }`` is `Any?`.\n\nThere's also the issue that for types that have their own `div` operator, e.g. ``bool `?` 1 / 2`` doesn't typecheck.\n\nHere's my shot at a fixed version:\n\n    typealias Thunk<T> = () -> T\n    typealias Ternary<T> = Pair<Thunk<T>, Thunk<T>>\n    infix fun <T> Boolean.`?`(tern: Ternary<T>) = if(this) tern.first() : tern.second()\n    operator fun Thunk<T>.div(rhs: Thunk<T>) = this to rhs\n    \n    val tmp = true\n    val w: String = tmp `?` { \"is true\" } / { \"is false\" }\n    val x: Any = tmp `?` { \"1\" } / { 0 }\n    val y: Int? = tmp `?` { 1 } / { null }\n    val z: Boolean = tmp `?` { true } / { throw Exception() } // subtyping with Nothing type works too","body_html":"<div class=\"md\"><ol><li> Обе стороны оцениваются. Поскольку оператором является <code>&lt;T&gt; T.div(rhs: T)</code> а не <code>&lt;T&gt; (() -&gt; T).div(rhs: () -&gt; T)</code> , оба аргумента оцениваются с нетерпением. </li><li> Типы возвращаемых функций ковариантны, поэтому он компилируется, но тип <code>bool `?` &quot;&#39; / { Unit }</code> - <code>Any?</code> . </li></ol><p> Также существует проблема, связанная с тем, что для типов, которые имеют собственный оператор <code>div</code> , например, <code>bool `?` 1 / 2</code> , проверка типов не выполняется. </p><p> Вот мой снимок с фиксированной версией: </p><pre> <code>typealias Thunk&lt;T&gt; = () -&gt; T typealias Ternary&lt;T&gt; = Pair&lt;Thunk&lt;T&gt;, Thunk&lt;T&gt;&gt; infix fun &lt;T&gt; Boolean.`?`(tern: Ternary&lt;T&gt;) = if(this) tern.first() : tern.second() operator fun Thunk&lt;T&gt;.div(rhs: Thunk&lt;T&gt;) = this to rhs val tmp = true val w: String = tmp `?` { &quot;is true&quot; } / { &quot;is false&quot; } val x: Any = tmp `?` { &quot;1&quot; } / { 0 } val y: Int? = tmp `?` { 1 } / { null } val z: Boolean = tmp `?` { true } / { throw Exception() } // subtyping with Nothing type works too</code> </pre></div>","permalink":"/r/Kotlin/comments/cdotu0/intellectuals_will_understand/etxsy6h/","name":"t1_etxsy6h","created":1563335469,"created_utc":1563306669,"subreddit_name_prefixed":"r/Kotlin","depth":2}],"id":"etviz6n","author":"Life_is_a_meme","parent_id":"t3_cdotu0","subreddit_id":"t5_2so2r","body":"While a rather funny post, it actually isn't a correct ternary since the case\n\n**true \\`?\\` \"X\" / ({ println(\"side effects\") })()**\n\nimproperly evaluates the right hand side.\nAnd with that lambda on the right hand side, you can effectively return anything (above returns Unit naturally)","body_html":"<div class=\"md\"><p> Хотя это довольно забавный пост, на самом деле это неправильная троица </p><p> <strong>true `?` &quot;X&quot; / ({println (&quot;побочные эффекты&quot;)}) ()</strong> </p><p> неправильно оценивает правую часть. И с этой лямбдой с правой стороны, вы можете эффективно вернуть все что угодно (выше возвращает Unit, естественно) </p></div>","permalink":"/r/Kotlin/comments/cdotu0/intellectuals_will_understand/etviz6n/","name":"t1_etviz6n","created":1563265436,"created_utc":1563236636,"subreddit_name_prefixed":"r/Kotlin","depth":0},{"ups":76,"link_id":"t3_cdotu0","replies":[{"ups":1,"link_id":"t3_cdotu0","id":"etxnghz","author":"my_name_isnt_clever","parent_id":"t1_etwj1sq","subreddit_id":"t5_2so2r","body":"I personally like it as it's just the language following it's own rules, rather than adding unique syntax just to save some space. Like, when I started Java I had no idea what these statements were that had a colon and question mark until I looked it up. In Kotlin, I see `return if (myVar) thingOne else thingTwo` and I already know what that does.","body_html":"<div class=\"md\"><p> Мне лично это нравится, так как это просто язык, который следует своим собственным правилам, а не добавлению уникального синтаксиса просто для экономии места. Например, когда я запустил Java, я понятия не имел, что это за утверждения, которые имели двоеточие и вопросительный знак, пока не посмотрел. В Kotlin я вижу <code>return if (myVar) thingOne else thingTwo</code> и я уже знаю, что это делает. </p></div>","permalink":"/r/Kotlin/comments/cdotu0/intellectuals_will_understand/etxnghz/","name":"t1_etxnghz","created":1563331984,"created_utc":1563303184,"subreddit_name_prefixed":"r/Kotlin","depth":2}],"id":"etvcdis","author":"KamiKagutsuchi","parent_id":"t3_cdotu0","subreddit_id":"t5_2so2r","body":"Why the hell would you want the ternary operator? It's exclusion from kotlin in favor of if-expressions was a great choice.","body_html":"<div class=\"md\"><p> Какого черта ты хочешь троичного оператора? Это исключение из kotlin в пользу if-выражений было отличным выбором. </p></div>","permalink":"/r/Kotlin/comments/cdotu0/intellectuals_will_understand/etvcdis/","name":"t1_etvcdis","created":1563260506,"created_utc":1563231706,"subreddit_name_prefixed":"r/Kotlin","depth":0},{"ups":5,"link_id":"t3_cdotu0","id":"etw11uq","author":"phlyrox","parent_id":"t3_cdotu0","subreddit_id":"t5_2so2r","body":"Is this feature at top of your wish [ ]","body_html":"<div class=\"md\"><p> Эта функция на вершине вашего желания [] </p></div>","permalink":"/r/Kotlin/comments/cdotu0/intellectuals_will_understand/etw11uq/","name":"t1_etw11uq","created":1563279161,"created_utc":1563250361,"subreddit_name_prefixed":"r/Kotlin","depth":0},{"ups":3,"link_id":"t3_cdotu0","id":"etw45nl","author":"SuperFluffyPunch","parent_id":"t3_cdotu0","subreddit_id":"t5_2so2r","body":"I got dizzy trying to read the code in OP","body_html":"<div class=\"md\"><p> У меня закружилась голова при попытке прочитать код в OP </p></div>","permalink":"/r/Kotlin/comments/cdotu0/intellectuals_will_understand/etw45nl/","name":"t1_etw45nl","created":1563282122,"created_utc":1563253322,"subreddit_name_prefixed":"r/Kotlin","depth":0},{"ups":2,"link_id":"t3_cdotu0","id":"etwucwj","author":"antanas-a","parent_id":"t3_cdotu0","subreddit_id":"t5_2so2r","body":"I'm missing this also. I'm currently using more `when` not `if else` as if else sometimes feel awkward when auto formatted\n```\nDataClass(\n  property = when (expression) {\n     true -> \"X\"\n     false -> \"Y\"\n    }\n)\n```","body_html":"<div class=\"md\"><p> Я тоже скучаю по этому. В настоящее время я использую больше, <code>when</code> нет, <code>if else</code> как-то <code>if else</code> как будто иногда чувствую себя неловко, когда автоматически форматируется <code>DataClass( property = when (expression) { true -&gt; &quot;X&quot; false -&gt; &quot;Y&quot; } )</code> </p></div>","permalink":"/r/Kotlin/comments/cdotu0/intellectuals_will_understand/etwucwj/","name":"t1_etwucwj","created":1563313104,"created_utc":1563284304,"subreddit_name_prefixed":"r/Kotlin","depth":0},{"ups":3,"link_id":"t3_cdotu0","id":"etvk90f","author":"Repsfivejesus","parent_id":"t3_cdotu0","subreddit_id":"t5_2so2r","body":"I'M DECEASED","body_html":"<div class=\"md\"><p> Я УМЕНЬШЕН </p></div>","permalink":"/r/Kotlin/comments/cdotu0/intellectuals_will_understand/etvk90f/","name":"t1_etvk90f","created":1563266384,"created_utc":1563237584,"subreddit_name_prefixed":"r/Kotlin","depth":0},{"ups":5,"link_id":"t3_cdotu0","replies":[{"ups":1,"link_id":"t3_cdotu0","id":"eu3yh1r","author":"izuriel","parent_id":"t1_eu2856p","subreddit_id":"t5_2so2r","body":"It’s pretty common to do that because most people are taught by people that don’t know this fact. And then others reaffirm the name because they also either don’t know or fell into bad habits or don’t care.","body_html":"<div class=\"md\"><p> Это довольно распространено, потому что большинство людей учат люди, которые не знают этого факта. А потом другие подтверждают имя, потому что они либо не знают, либо впали в плохие привычки, либо им все равно. </p></div>","permalink":"/r/Kotlin/comments/cdotu0/intellectuals_will_understand/eu3yh1r/","name":"t1_eu3yh1r","created":1563458916,"created_utc":1563430116,"subreddit_name_prefixed":"r/Kotlin","depth":2}],"id":"etvrrr1","author":"izuriel","parent_id":"t3_cdotu0","subreddit_id":"t5_2so2r","body":"So. This isn’t _the_ ternary operator. Sure. As far as ternary operators go this is pretty much the only one you see. It is the “conditional” operator. It’s a ternary operator because it operates on three values (condition, true result and false result). But calling it “the ternary operator” would be like calling addition “the binary operator.”","body_html":"<div class=\"md\"><p> Так. Это не тройной оператор. Конечно. Что касается троичных операторов, то это практически единственный, который вы видите. Это «условный» оператор. Это троичный оператор, потому что он работает с тремя значениями (условие, истинный результат и ложный результат). Но называть его «троичным оператором» все равно, что называть сложение «бинарным оператором». </p></div>","permalink":"/r/Kotlin/comments/cdotu0/intellectuals_will_understand/etvrrr1/","name":"t1_etvrrr1","created":1563271855,"created_utc":1563243055,"subreddit_name_prefixed":"r/Kotlin","depth":0}]}