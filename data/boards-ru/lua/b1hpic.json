{"subreddit":{"display_name":"lua"},"subreddit_loc":"принимать","selftext":"Привет всем. У меня проблема с самодельной реализацией алгоритма быстрой сортировки. Вот код, который я написал.\n\n    функция быстрой сортировки (список)\n      если #list <= 1, то\n        список возврата\n      конец\n      local pivot = table.remove (list, #list)\n      местный l, g = {}, {}\n      для i = 1, #list do\n        если список [i]> pivot то\n          g [# g + 1] = список [i]\n        еще\n          l [# l + 1] = список [i]\n        конец\n      конец\n      return {table.unpack (quicksort (l)), pivot, table.unpack (quicksort (g))}\n    конец\n\nЭта функция должна принимать таблицу чисел в качестве аргумента и возвращать другую таблицу, содержащую те же элементы, но упорядоченные.\n\nПрежде всего, возвращаемая таблица не является последовательностью, поэтому я не могу использовать итератор ipairs, чтобы распечатать ее, но это не имеет большого значения, поскольку даже при использовании итератора пар она печатает таблицу правильно.\n\nПроблема в том, что этот код работает только для определенных таблиц, поэтому я бы сказал, что он не работает! У кого-нибудь есть предложения, как это исправить? Моя проблема связана с оператором возврата? Спасибо всем заранее :)\n\n\n\nИзменить: способ, которым я пытался реализовать это, связан с тем, что мне нравится функциональная парадигма. Если возможно, я бы хотел сохранить простую реализацию, предпочитая, если возможно, рекурсию итерации.","title":"Проблема с пользовательской реализацией алгоритма быстрой сортировки","subreddit_name_prefixed":"r/lua","ups":5,"created":1552699895,"link_flair_background_color":"","id":"b1hpic","author":{"name":"Sghebre"},"permalink":"/r/lua/comments/b1hpic/problem_with_custom_implementation_of_quicksort/","url":"https://www.reddit.com/r/lua/comments/b1hpic/problem_with_custom_implementation_of_quicksort/","created_utc":1552671095}