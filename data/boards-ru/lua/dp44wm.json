{"subreddit":{"display_name":"lua"},"subreddit_loc":"принимать","selftext":"Проблема с debug.getinfo (foo, \"L\") в том, что он возвращает активную строку только текущей функции, а не подфункций.\n\n\nТехнически, файл - это функция.\n\nИдея состоит в том, чтобы проверить, является ли строка в определенном файле «активной», поэтому я использую `loadfile`, чтобы превратить файл в функцию.\n\nТеперь я могу найти все активные строки в этом файле, которые не являются частью функции.\n\nЯ могу найти все существующие функции ** (включая локальные) **, используя `jit.util.funck`, они являются` proto`s.\n\n\nПроблема в том, что `debug.getinfo` вообще не работает с протосами, я могу прочитать байт-код любого прото, игрушку с ним, но\" родной \"lua 5.1 не будет принимать протос и сообщать мне, какие строки активны.\n\n\nРазбор кода Lua вручную, очевидно, не является хорошим способом сделать это.\n\n\nВ протоколе есть отладочная информация:\n\n\ntypedef struct GCproto {\nGCHeader;\nuint8_t numparams; / * Количество параметров. * /\nuint8_t framesize; / * Фиксированный размер кадра. * /\nMSize sizebc; / * Количество инструкций байт-кода. * /\n#if LJ_GC64\nuint32_t unused_gc64;\n#endif\nGCRef gclist;\nMRef k; / * Разделить постоянный массив (указывает на середину). * /\nMRef uv; / * Upvalue список. локальный слот | 0x8000 или родительский uv idx. * /\nMSize sizekgc; / * Количество собираемых констант. * /\nMSize sizekn; / * Количество констант lua_Number. * /\nMSize sizept; / * Общий размер, включая совмещенные массивы. * /\nuint8_t sizeuv; / * Количество повышений. * /\nфлаги uint8_t; / * Разные флаги (см. Ниже). * /\nтрассировка uint16_t; / * Якорь для цепочки корневых следов. * /\n/ * ------ Следующие поля предназначены только для отладки / трассировки ------ * /\nGCRef chunkname; / * Имя блока, в котором была определена эта функция. * /\nBCLine первая линия; / * Первая строка определения функции. * /\nBCLine numline; / * Количество строк для определения функции. * /\nMRef lineinfo; / * Сжатая карта из байт-кода ins. к исходной строке. * /\nMRef uvinfo; / * Upvalue имена. * /\nMRef varinfo; / * Имена и сжатые экстенты локальных переменных. * /\n} GCproto;\n\n\nСмотрите ссылку на строку lineInfo в конце структуры.\n\n\nЭта функция также существует\n\n\n/ * Получить номер строки для позиции байт-кода. * /\nBCLine LJ_FASTCALL lj_debug_line (GCproto * pt, BCPos pc)\n\n\n# Взлом, найденный в комментариях, работает только для luajit","title":"[LuaJIT] debug.getinfo о протос / подфункции","subreddit_name_prefixed":"r/lua","ups":7,"created":1572454980,"link_flair_background_color":"","id":"dp44wm","author":{"name":"ExtReM_Lapin"},"permalink":"/r/lua/comments/dp44wm/luajit_debuggetinfo_on_protossubfunction/","url":"https://www.reddit.com/r/lua/comments/dp44wm/luajit_debuggetinfo_on_protossubfunction/","created_utc":1572426180}